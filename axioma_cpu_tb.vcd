$date
	Sat Jul 19 22:44:58 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module axioma_cpu_tb $end
$var wire 8 ! status_reg [7:0] $end
$var wire 16 " program_addr [15:0] $end
$var wire 8 # debug_reg_r17 [7:0] $end
$var wire 8 $ debug_reg_r16 [7:0] $end
$var wire 16 % debug_pc [15:0] $end
$var wire 16 & debug_instruction [15:0] $end
$var wire 1 ' data_write $end
$var wire 1 ( data_read $end
$var wire 8 ) data_out [7:0] $end
$var wire 16 * data_addr [15:0] $end
$var wire 1 + cpu_halted $end
$var reg 1 , clk $end
$var reg 8 - data_in [7:0] $end
$var reg 1 . data_ready $end
$var reg 16 / program_data [15:0] $end
$var reg 1 0 program_ready $end
$var reg 1 1 reset_n $end
$scope module dut $end
$var wire 1 , clk $end
$var wire 8 2 data_in [7:0] $end
$var wire 1 . data_ready $end
$var wire 16 3 debug_instruction [15:0] $end
$var wire 16 4 debug_pc [15:0] $end
$var wire 8 5 debug_reg_r16 [7:0] $end
$var wire 8 6 debug_reg_r17 [7:0] $end
$var wire 16 7 program_data [15:0] $end
$var wire 1 0 program_ready $end
$var wire 1 1 reset_n $end
$var wire 1 8 sreg_z $end
$var wire 1 9 sreg_v $end
$var wire 1 : sreg_t $end
$var wire 1 ; sreg_s $end
$var wire 1 < sreg_n $end
$var wire 1 = sreg_i $end
$var wire 1 > sreg_h $end
$var wire 1 ? sreg_c $end
$var wire 16 @ reg_z_pointer [15:0] $end
$var wire 16 A reg_y_pointer [15:0] $end
$var wire 16 B reg_x_pointer [15:0] $end
$var wire 8 C reg_rs2_data [7:0] $end
$var wire 8 D reg_rs1_data [7:0] $end
$var wire 1 E dec_use_pointer $end
$var wire 1 F dec_unsupported_instruction $end
$var wire 5 G dec_rs2_addr [4:0] $end
$var wire 5 H dec_rs1_addr [4:0] $end
$var wire 1 I dec_rd_write_en $end
$var wire 5 J dec_rd_addr [4:0] $end
$var wire 2 K dec_pointer_sel [1:0] $end
$var wire 1 L dec_mem_write $end
$var wire 1 M dec_mem_read $end
$var wire 1 N dec_jump_en $end
$var wire 22 O dec_jump_addr [21:0] $end
$var wire 1 P dec_instruction_decoded $end
$var wire 8 Q dec_immediate [7:0] $end
$var wire 12 R dec_branch_offset [11:0] $end
$var wire 1 S dec_branch_en $end
$var wire 3 T dec_branch_condition [2:0] $end
$var wire 1 U dec_alu_use_immediate $end
$var wire 5 V dec_alu_op [4:0] $end
$var wire 8 W alu_result [7:0] $end
$var wire 8 X alu_operand_b [7:0] $end
$var wire 1 Y alu_flag_z $end
$var wire 1 Z alu_flag_v $end
$var wire 1 [ alu_flag_s $end
$var wire 1 \ alu_flag_n $end
$var wire 1 ] alu_flag_h $end
$var wire 1 ^ alu_flag_c $end
$var reg 1 _ alu_update_flags $end
$var reg 1 + cpu_halted $end
$var reg 2 ` cpu_state [1:0] $end
$var reg 16 a data_addr [15:0] $end
$var reg 8 b data_out [7:0] $end
$var reg 1 ( data_read $end
$var reg 1 ' data_write $end
$var reg 16 c instruction_reg [15:0] $end
$var reg 1 d instruction_valid $end
$var reg 2 e next_state [1:0] $end
$var reg 16 f pc [15:0] $end
$var reg 16 g program_addr [15:0] $end
$var reg 8 h reg_rd_data [7:0] $end
$var reg 1 i reg_rd_write_en $end
$var reg 8 j status_reg [7:0] $end
$scope function branch_taken $end
$var reg 3 k condition [2:0] $end
$var reg 8 l sreg [7:0] $end
$upscope $end
$scope module alu_inst $end
$var wire 1 , clk $end
$var wire 1 ? flag_c_in $end
$var wire 1 > flag_h_in $end
$var wire 1 < flag_n_in $end
$var wire 1 ; flag_s_in $end
$var wire 1 9 flag_v_in $end
$var wire 1 8 flag_z_in $end
$var wire 8 m operand_b [7:0] $end
$var wire 1 1 reset_n $end
$var wire 9 n sub_result [8:0] $end
$var wire 8 o operand_a [7:0] $end
$var wire 5 p alu_op [4:0] $end
$var wire 9 q add_result [8:0] $end
$var reg 1 ^ flag_c_out $end
$var reg 1 ] flag_h_out $end
$var reg 1 \ flag_n_out $end
$var reg 1 [ flag_s_out $end
$var reg 1 Z flag_v_out $end
$var reg 1 Y flag_z_out $end
$var reg 8 r result [7:0] $end
$upscope $end
$scope module decoder_inst $end
$var wire 1 , clk $end
$var wire 16 s instruction [15:0] $end
$var wire 1 d instruction_valid $end
$var wire 1 1 reset_n $end
$var wire 5 t rr_field [4:0] $end
$var wire 5 u rd_field [4:0] $end
$var wire 4 v opcode_mid [3:0] $end
$var wire 4 w opcode_low [3:0] $end
$var wire 4 x opcode_high [3:0] $end
$var wire 4 y opcode_bottom [3:0] $end
$var wire 8 z k8_immediate [7:0] $end
$var wire 6 { k6_immediate [5:0] $end
$var reg 5 | alu_op [4:0] $end
$var reg 1 U alu_use_immediate $end
$var reg 3 } branch_condition [2:0] $end
$var reg 1 S branch_en $end
$var reg 12 ~ branch_offset [11:0] $end
$var reg 8 !" immediate [7:0] $end
$var reg 1 P instruction_decoded $end
$var reg 22 "" jump_addr [21:0] $end
$var reg 1 N jump_en $end
$var reg 1 M mem_read $end
$var reg 1 L mem_write $end
$var reg 2 #" pointer_sel [1:0] $end
$var reg 5 $" rd_addr [4:0] $end
$var reg 1 I rd_write_en $end
$var reg 5 %" rs1_addr [4:0] $end
$var reg 5 &" rs2_addr [4:0] $end
$var reg 1 F unsupported_instruction $end
$var reg 1 E use_pointer $end
$upscope $end
$scope module registers_inst $end
$var wire 1 , clk $end
$var wire 5 '" rd_addr [4:0] $end
$var wire 8 (" rd_data [7:0] $end
$var wire 1 i rd_write_en $end
$var wire 1 1 reset_n $end
$var wire 5 )" rs1_addr [4:0] $end
$var wire 8 *" rs1_data [7:0] $end
$var wire 5 +" rs2_addr [4:0] $end
$var wire 8 ," rs2_data [7:0] $end
$var wire 16 -" x_pointer_in [15:0] $end
$var wire 1 ." x_write_en $end
$var wire 16 /" y_pointer_in [15:0] $end
$var wire 1 0" y_write_en $end
$var wire 16 1" z_pointer_in [15:0] $end
$var wire 1 2" z_write_en $end
$var wire 16 3" z_pointer [15:0] $end
$var wire 16 4" y_pointer [15:0] $end
$var wire 16 5" x_pointer [15:0] $end
$var integer 32 6" i [31:0] $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop0 $end
$var integer 32 7" i [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 7"
b100000 6"
b0 5"
b0 4"
b0 3"
02"
b0 1"
00"
b0 /"
0."
b0 -"
b0 ,"
b0 +"
b0 *"
b0 )"
b0 ("
b0 '"
b0 &"
b0 %"
b0 $"
b0 #"
b0 ""
b0 !"
b0 ~
b0 }
b11111 |
b0 {
b0 z
b0 y
b0 x
b0 w
b0 v
b0 u
b0 t
b0 s
b0 r
b0 q
b11111 p
b0 o
b0 n
b0 m
bx l
bx k
b0 j
0i
b0 h
b0 g
b0 f
b1 e
0d
b0 c
b0 b
b0 a
b0 `
0_
0^
0]
0\
0[
0Z
1Y
b0 X
b0 W
b11111 V
0U
b0 T
0S
b0 R
b0 Q
0P
b0 O
0N
0M
0L
b0 K
b0 J
0I
b0 H
b0 G
0F
0E
b0 D
b0 C
b0 B
b0 A
b0 @
0?
0>
0=
0<
0;
0:
09
08
b1110000000000101 7
b0 6
b0 5
b0 4
b0 3
b0 2
01
10
b1110000000000101 /
1.
b0 -
0,
0+
b0 *
b0 )
0(
0'
b0 &
b0 %
b0 $
b0 #
b0 "
b0 !
$end
#10000
b100000 6"
1,
#20000
0,
#30000
b100000 6"
1,
#40000
0,
#50000
1Y
b101 q
b111111011 n
b101 X
b101 m
1_
1i
1P
b101 Q
b101 !"
1U
1I
b10000 J
b10000 $"
b10000 '"
b1110 x
b101 y
b101 t
b0 e
b0 "
b0 g
1d
b1110000000000101 &
b1110000000000101 3
b1110000000000101 c
b1110000000000101 s
b1 `
1,
11
#60000
0,
#70000
1Y
b0 q
b0 n
b0 X
b0 m
b1110000000010011 /
b1110000000010011 7
18
0P
b0 Q
b0 !"
0U
0I
b0 J
b0 $"
b0 '"
b1 e
0_
0i
b1 "
b1 g
b10 !
b10 j
b1 %
b1 4
b1 f
0d
b0 `
b0 k
b0 l
1,
#80000
0,
#90000
1Y
b11 q
b111111101 n
b11 X
b11 m
1_
1i
1P
b11 Q
b11 !"
1U
1I
b10001 J
b10001 $"
b10001 '"
b1 w
b11 y
b1 u
b11 t
b1 z
b1 {
b0 e
b1 "
b1 g
1d
b1110000000010011 &
b1110000000010011 3
b1110000000010011 c
b1110000000010011 s
b1 `
1,
#100000
0,
#110000
1Y
b0 q
b0 n
b0 X
b0 m
b111100000001 /
b111100000001 7
0P
b0 Q
b0 !"
0U
0I
b0 J
b0 $"
b0 '"
b1 e
0_
0i
b10 "
b10 g
b10 %
b10 4
b10 f
0d
b0 `
b10 l
1,
#120000
0,
#130000
1F
b0 x
b1111 v
b0 w
b1 y
b10000 u
b10001 t
b11110000 z
b110000 {
b11 e
b10 "
b10 g
1d
b111100000001 &
b111100000001 3
b111100000001 c
b111100000001 s
b1 `
1,
#140000
0,
#150000
0F
1+
0d
b11 `
1,
#160000
0,
#170000
1,
